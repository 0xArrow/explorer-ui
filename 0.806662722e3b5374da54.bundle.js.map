{"version":3,"file":"0.806662722e3b5374da54.bundle.js","sources":["webpack:///./node_modules/react-transition-group/index.js","webpack:///./node_modules/@alethio/ui/lib/layout/content/box/Box.js","webpack:///./node_modules/react-transition-group/Transition.js","webpack:///./node_modules/@alethio/ui/lib/control/menu/Menu.js","webpack:///./node_modules/@alethio/ui/lib/fx/Fade.js","webpack:///./node_modules/@alethio/ui/lib/control/menu/MenuItem.js"],"sourcesContent":["\"use strict\";\n\nvar _CSSTransition = _interopRequireDefault(require(\"./CSSTransition\"));\n\nvar _ReplaceTransition = _interopRequireDefault(require(\"./ReplaceTransition\"));\n\nvar _TransitionGroup = _interopRequireDefault(require(\"./TransitionGroup\"));\n\nvar _Transition = _interopRequireDefault(require(\"./Transition\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = {\n  Transition: _Transition.default,\n  TransitionGroup: _TransitionGroup.default,\n  ReplaceTransition: _ReplaceTransition.default,\n  CSSTransition: _CSSTransition.default\n};","import styled, { css } from \"../../../styled-components\";\r\nimport * as React from \"react\";\r\nconst IconRoot = styled.div.withConfig({ displayName: \"IconRoot\", componentId: \"sc-f5tt8o\" }) `\n    display: block;\n    /* Let the parent element handle mouse events (\n        because SVG is special and causes problems when used in menu layer with document click outside detection\n    ) */\n    pointer-events: none;\n`;\r\nconst ContentRoot = styled(\"div\").withConfig({ displayName: \"ContentRoot\", componentId: \"sc-fyzi41\" }) `\n    padding-top: ${props => props.paddingTop}px;\n    white-space: nowrap;\n\n    ${props => props.fullWidth ? css `\n    width: 100%;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    ` : ``}\n`;\r\nconst $Box = ({ children, className, Icon, iconPlacement, metrics, fullWidth }) => {\r\n    let icon = Icon ?\r\n        React.createElement(IconRoot, null,\r\n            React.createElement(Icon, { size: metrics.iconSize }))\r\n        : null;\r\n    let iconIsLeft = iconPlacement === \"left\";\r\n    return React.createElement(\"div\", { className: className },\r\n        iconIsLeft && icon,\r\n        children !== void 0 ?\r\n            React.createElement(ContentRoot, { fullWidth: fullWidth, paddingTop: metrics.textPaddingTop }, children)\r\n            : null,\r\n        !iconIsLeft && icon);\r\n};\r\nconst getColors = (colors, theme) => {\r\n    if (typeof colors === \"function\") {\r\n        return colors(theme);\r\n    }\r\n    return colors;\r\n};\r\nconst BORDER_WIDTH = 1;\r\nexport const Box = styled($Box).withConfig({ displayName: \"Box\", componentId: \"sc-an678j\" }) `\n    display: flex;\n    font-size: ${props => props.metrics.fontSize}px;\n    line-height: ${props => props.metrics.lineHeight}px;\n    height: ${props => props.metrics.height}px;\n\n    ${props => props.fullWidth ? css `\n    width: 100%;\n    ` : ``}\n\n    padding: 0 ${props => props.metrics.textPaddingX - BORDER_WIDTH}px;\n\n    ${props => {\r\n    if (!props.Icon) {\r\n        return;\r\n    }\r\n    let hasText = props.children !== void 0;\r\n    let iconTextSpacing = Math.floor(props.metrics.textPaddingX / 2);\r\n    let iconMarginY = Math.max(0, (props.metrics.height - props.metrics.iconSize) / 2 - BORDER_WIDTH);\r\n    let iconMarginX = hasText ? iconTextSpacing : iconMarginY;\r\n    let iconIsLeft = props.iconPlacement === \"left\";\r\n    return css `\n            ${iconIsLeft ? css `\n                padding-left: ${iconMarginX}px;\n                    ${!hasText ? css `\n                    padding-right: ${iconMarginX}px;\n                    ` : ``}\n                ` : css `\n                padding-right: ${iconMarginX}px;\n                    ${!hasText ? css `\n                    padding-left: ${iconMarginX}px;\n                    ` : ``}\n            `}\n\n            & ${IconRoot} {\n                margin-top: ${iconMarginY}px;\n\n                ${hasText ? css `\n                    ${iconIsLeft ? css `\n                        margin-right: ${iconTextSpacing}px;\n                        ` : css `\n                        margin-left: ${iconTextSpacing}px;`}\n                ` : ``}\n            }\n        `;\r\n}}\n\n    font-weight: ${props => props.metrics.fontWeight};\n    letter-spacing: ${props => props.metrics.letterSpacing};\n    box-sizing: border-box;\n    vertical-align: middle;\n\n    border: ${BORDER_WIDTH}px solid ${props => (getColors(props.colors, props.theme).border ||\r\n    getColors(props.colors, props.theme).background ||\r\n    \"transparent\")};\n    border-radius: ${props => props.theme.spacing.borderRadius.thin}px;\n    background-color: ${props => (getColors(props.colors, props.theme).background || \"transparent\")};\n    color: ${props => getColors(props.colors, props.theme).text};\n`;\r\n//# sourceMappingURL=Box.js.map","\"use strict\";\n\nexports.__esModule = true;\nexports.default = exports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = void 0;\n\nvar PropTypes = _interopRequireWildcard(require(\"prop-types\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _reactDom = _interopRequireDefault(require(\"react-dom\"));\n\nvar _reactLifecyclesCompat = require(\"react-lifecycles-compat\");\n\nvar _PropTypes = require(\"./utils/PropTypes\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar UNMOUNTED = 'unmounted';\nexports.UNMOUNTED = UNMOUNTED;\nvar EXITED = 'exited';\nexports.EXITED = EXITED;\nvar ENTERING = 'entering';\nexports.ENTERING = ENTERING;\nvar ENTERED = 'entered';\nexports.ENTERED = ENTERED;\nvar EXITING = 'exiting';\n/**\n * The Transition component lets you describe a transition from one component\n * state to another _over time_ with a simple declarative API. Most commonly\n * it's used to animate the mounting and unmounting of a component, but can also\n * be used to describe in-place transition states as well.\n *\n * ---\n *\n * **Note**: `Transition` is a platform-agnostic base component. If you're using\n * transitions in CSS, you'll probably want to use\n * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)\n * instead. It inherits all the features of `Transition`, but contains\n * additional features necessary to play nice with CSS transitions (hence the\n * name of the component).\n *\n * ---\n *\n * By default the `Transition` component does not alter the behavior of the\n * component it renders, it only tracks \"enter\" and \"exit\" states for the\n * components. It's up to you to give meaning and effect to those states. For\n * example we can add styles to a component when it enters or exits:\n *\n * ```jsx\n * import { Transition } from 'react-transition-group';\n *\n * const duration = 300;\n *\n * const defaultStyle = {\n *   transition: `opacity ${duration}ms ease-in-out`,\n *   opacity: 0,\n * }\n *\n * const transitionStyles = {\n *   entering: { opacity: 0 },\n *   entered:  { opacity: 1 },\n * };\n *\n * const Fade = ({ in: inProp }) => (\n *   <Transition in={inProp} timeout={duration}>\n *     {state => (\n *       <div style={{\n *         ...defaultStyle,\n *         ...transitionStyles[state]\n *       }}>\n *         I'm a fade Transition!\n *       </div>\n *     )}\n *   </Transition>\n * );\n * ```\n *\n * There are 4 main states a Transition can be in:\n *  - `'entering'`\n *  - `'entered'`\n *  - `'exiting'`\n *  - `'exited'`\n *\n * Transition state is toggled via the `in` prop. When `true` the component\n * begins the \"Enter\" stage. During this stage, the component will shift from\n * its current transition state, to `'entering'` for the duration of the\n * transition and then to the `'entered'` stage once it's complete. Let's take\n * the following example (we'll use the\n * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):\n *\n * ```jsx\n * function App() {\n *   const [inProp, setInProp] = useState(false);\n *   return (\n *     <div>\n *       <Transition in={inProp} timeout={500}>\n *         {state => (\n *           // ...\n *         )}\n *       </Transition>\n *       <button onClick={() => setInProp(true)}>\n *         Click to Enter\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the button is clicked the component will shift to the `'entering'` state\n * and stay there for 500ms (the value of `timeout`) before it finally switches\n * to `'entered'`.\n *\n * When `in` is `false` the same thing happens except the state moves from\n * `'exiting'` to `'exited'`.\n */\n\nexports.EXITING = EXITING;\n\nvar Transition =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(Transition, _React$Component);\n\n  function Transition(props, context) {\n    var _this;\n\n    _this = _React$Component.call(this, props, context) || this;\n    var parentGroup = context.transitionGroup; // In the context of a TransitionGroup all enters are really appears\n\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\n    var initialStatus;\n    _this.appearStatus = null;\n\n    if (props.in) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.appearStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else {\n      if (props.unmountOnExit || props.mountOnEnter) {\n        initialStatus = UNMOUNTED;\n      } else {\n        initialStatus = EXITED;\n      }\n    }\n\n    _this.state = {\n      status: initialStatus\n    };\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  var _proto = Transition.prototype;\n\n  _proto.getChildContext = function getChildContext() {\n    return {\n      transitionGroup: null // allows for nested Transitions\n\n    };\n  };\n\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\n    var nextIn = _ref.in;\n\n    if (nextIn && prevState.status === UNMOUNTED) {\n      return {\n        status: EXITED\n      };\n    }\n\n    return null;\n  }; // getSnapshotBeforeUpdate(prevProps) {\n  //   let nextStatus = null\n  //   if (prevProps !== this.props) {\n  //     const { status } = this.state\n  //     if (this.props.in) {\n  //       if (status !== ENTERING && status !== ENTERED) {\n  //         nextStatus = ENTERING\n  //       }\n  //     } else {\n  //       if (status === ENTERING || status === ENTERED) {\n  //         nextStatus = EXITING\n  //       }\n  //     }\n  //   }\n  //   return { nextStatus }\n  // }\n\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.updateStatus(true, this.appearStatus);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var nextStatus = null;\n\n    if (prevProps !== this.props) {\n      var status = this.state.status;\n\n      if (this.props.in) {\n        if (status !== ENTERING && status !== ENTERED) {\n          nextStatus = ENTERING;\n        }\n      } else {\n        if (status === ENTERING || status === ENTERED) {\n          nextStatus = EXITING;\n        }\n      }\n    }\n\n    this.updateStatus(false, nextStatus);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n\n  _proto.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n    var exit, enter, appear;\n    exit = enter = appear = timeout;\n\n    if (timeout != null && typeof timeout !== 'number') {\n      exit = timeout.exit;\n      enter = timeout.enter; // TODO: remove fallback for next major\n\n      appear = timeout.appear !== undefined ? timeout.appear : enter;\n    }\n\n    return {\n      exit: exit,\n      enter: enter,\n      appear: appear\n    };\n  };\n\n  _proto.updateStatus = function updateStatus(mounting, nextStatus) {\n    if (mounting === void 0) {\n      mounting = false;\n    }\n\n    if (nextStatus !== null) {\n      // nextStatus will always be ENTERING or EXITING.\n      this.cancelNextCallback();\n\n      var node = _reactDom.default.findDOMNode(this);\n\n      if (nextStatus === ENTERING) {\n        this.performEnter(node, mounting);\n      } else {\n        this.performExit(node);\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({\n        status: UNMOUNTED\n      });\n    }\n  };\n\n  _proto.performEnter = function performEnter(node, mounting) {\n    var _this2 = this;\n\n    var enter = this.props.enter;\n    var appearing = this.context.transitionGroup ? this.context.transitionGroup.isMounting : mounting;\n    var timeouts = this.getTimeouts();\n    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED\n    // if we are mounting and running this it means appear _must_ be set\n\n    if (!mounting && !enter) {\n      this.safeSetState({\n        status: ENTERED\n      }, function () {\n        _this2.props.onEntered(node);\n      });\n      return;\n    }\n\n    this.props.onEnter(node, appearing);\n    this.safeSetState({\n      status: ENTERING\n    }, function () {\n      _this2.props.onEntering(node, appearing);\n\n      _this2.onTransitionEnd(node, enterTimeout, function () {\n        _this2.safeSetState({\n          status: ENTERED\n        }, function () {\n          _this2.props.onEntered(node, appearing);\n        });\n      });\n    });\n  };\n\n  _proto.performExit = function performExit(node) {\n    var _this3 = this;\n\n    var exit = this.props.exit;\n    var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED\n\n    if (!exit) {\n      this.safeSetState({\n        status: EXITED\n      }, function () {\n        _this3.props.onExited(node);\n      });\n      return;\n    }\n\n    this.props.onExit(node);\n    this.safeSetState({\n      status: EXITING\n    }, function () {\n      _this3.props.onExiting(node);\n\n      _this3.onTransitionEnd(node, timeouts.exit, function () {\n        _this3.safeSetState({\n          status: EXITED\n        }, function () {\n          _this3.props.onExited(node);\n        });\n      });\n    });\n  };\n\n  _proto.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n\n  _proto.safeSetState = function safeSetState(nextState, callback) {\n    // This shouldn't be necessary, but there are weird race conditions with\n    // setState callbacks and unmounting in testing, so always make sure that\n    // we can cancel any pending setState callbacks after we unmount.\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, callback);\n  };\n\n  _proto.setNextCallback = function setNextCallback(callback) {\n    var _this4 = this;\n\n    var active = true;\n\n    this.nextCallback = function (event) {\n      if (active) {\n        active = false;\n        _this4.nextCallback = null;\n        callback(event);\n      }\n    };\n\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n\n    return this.nextCallback;\n  };\n\n  _proto.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {\n    this.setNextCallback(handler);\n    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;\n\n    if (!node || doesNotHaveTimeoutOrListener) {\n      setTimeout(this.nextCallback, 0);\n      return;\n    }\n\n    if (this.props.addEndListener) {\n      this.props.addEndListener(node, this.nextCallback);\n    }\n\n    if (timeout != null) {\n      setTimeout(this.nextCallback, timeout);\n    }\n  };\n\n  _proto.render = function render() {\n    var status = this.state.status;\n\n    if (status === UNMOUNTED) {\n      return null;\n    }\n\n    var _this$props = this.props,\n        children = _this$props.children,\n        childProps = _objectWithoutPropertiesLoose(_this$props, [\"children\"]); // filter props for Transtition\n\n\n    delete childProps.in;\n    delete childProps.mountOnEnter;\n    delete childProps.unmountOnExit;\n    delete childProps.appear;\n    delete childProps.enter;\n    delete childProps.exit;\n    delete childProps.timeout;\n    delete childProps.addEndListener;\n    delete childProps.onEnter;\n    delete childProps.onEntering;\n    delete childProps.onEntered;\n    delete childProps.onExit;\n    delete childProps.onExiting;\n    delete childProps.onExited;\n\n    if (typeof children === 'function') {\n      return children(status, childProps);\n    }\n\n    var child = _react.default.Children.only(children);\n\n    return _react.default.cloneElement(child, childProps);\n  };\n\n  return Transition;\n}(_react.default.Component);\n\nTransition.contextTypes = {\n  transitionGroup: PropTypes.object\n};\nTransition.childContextTypes = {\n  transitionGroup: function transitionGroup() {}\n};\nTransition.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * A `function` child can be used instead of a React element. This function is\n   * called with the current transition status (`'entering'`, `'entered'`,\n   * `'exiting'`, `'exited'`, `'unmounted'`), which can be used to apply context\n   * specific props to a component.\n   *\n   * ```jsx\n   * <Transition in={this.state.in} timeout={150}>\n   *   {state => (\n   *     <MyComponent className={`fade fade-${state}`} />\n   *   )}\n   * </Transition>\n   * ```\n   */\n  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,\n\n  /**\n   * Show the component; triggers the enter or exit states\n   */\n  in: PropTypes.bool,\n\n  /**\n   * By default the child component is mounted immediately along with\n   * the parent `Transition` component. If you want to \"lazy mount\" the component on the\n   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay\n   * mounted, even on \"exited\", unless you also specify `unmountOnExit`.\n   */\n  mountOnEnter: PropTypes.bool,\n\n  /**\n   * By default the child component stays mounted after it reaches the `'exited'` state.\n   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.\n   */\n  unmountOnExit: PropTypes.bool,\n\n  /**\n   * Normally a component is not transitioned if it is shown when the `<Transition>` component mounts.\n   * If you want to transition on the first mount set `appear` to `true`, and the\n   * component will transition in as soon as the `<Transition>` mounts.\n   *\n   * > Note: there are no specific \"appear\" states. `appear` only adds an additional `enter` transition.\n   */\n  appear: PropTypes.bool,\n\n  /**\n   * Enable or disable enter transitions.\n   */\n  enter: PropTypes.bool,\n\n  /**\n   * Enable or disable exit transitions.\n   */\n  exit: PropTypes.bool,\n\n  /**\n   * The duration of the transition, in milliseconds.\n   * Required unless `addEndListener` is provided.\n   *\n   * You may specify a single timeout for all transitions:\n   *\n   * ```jsx\n   * timeout={500}\n   * ```\n   *\n   * or individually:\n   *\n   * ```jsx\n   * timeout={{\n   *  appear: 500,\n   *  enter: 300,\n   *  exit: 500,\n   * }}\n   * ```\n   *\n   * - `appear` defaults to the value of `enter`\n   * - `enter` defaults to `0`\n   * - `exit` defaults to `0`\n   *\n   * @type {number | { enter?: number, exit?: number, appear?: number }}\n   */\n  timeout: function timeout(props) {\n    var pt = _PropTypes.timeoutsShape;\n    if (!props.addEndListener) pt = pt.isRequired;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return pt.apply(void 0, [props].concat(args));\n  },\n\n  /**\n   * Add a custom transition end trigger. Called with the transitioning\n   * DOM node and a `done` callback. Allows for more fine grained transition end\n   * logic. **Note:** Timeouts are still used as a fallback if provided.\n   *\n   * ```jsx\n   * addEndListener={(node, done) => {\n   *   // use the css transitionend event to mark the finish of a transition\n   *   node.addEventListener('transitionend', done, false);\n   * }}\n   * ```\n   */\n  addEndListener: PropTypes.func,\n\n  /**\n   * Callback fired before the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEnter: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntering: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entered\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEntered: PropTypes.func,\n\n  /**\n   * Callback fired before the \"exiting\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExit: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exiting\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExiting: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exited\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExited: PropTypes.func // Name the function so it is clearer in the documentation\n\n} : {};\n\nfunction noop() {}\n\nTransition.defaultProps = {\n  in: false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n  onEnter: noop,\n  onEntering: noop,\n  onEntered: noop,\n  onExit: noop,\n  onExiting: noop,\n  onExited: noop\n};\nTransition.UNMOUNTED = 0;\nTransition.EXITED = 1;\nTransition.ENTERING = 2;\nTransition.ENTERED = 3;\nTransition.EXITING = 4;\n\nvar _default = (0, _reactLifecyclesCompat.polyfill)(Transition);\n\nexports.default = _default;","import * as React from \"react\";\r\nimport styled from \"../../styled-components\";\r\nconst $Menu = styled.div.withConfig({ displayName: \"$Menu\", componentId: \"sc-1gfhy5x\" }) `\n    box-shadow: 0 8px 16px 0 rgba(167, 181, 209, 0.6);\n    border-radius: ${props => props.theme.spacing.borderRadius.normal}px;\n    padding: 8px 0;\n    max-height: ${props => props.maxHeight}px;\n    max-width: ${props => props.maxWidth}px;\n    overflow-y: auto;\n    background: ${props => props.theme.colors.menu.background};\n    cursor: default;\n`;\r\nexport class Menu extends React.Component {\r\n    render() {\r\n        return (React.createElement($Menu, Object.assign({}, this.props), this.props.children));\r\n    }\r\n}\r\nMenu.defaultProps = {\r\n    maxHeight: 300\r\n};\r\n//# sourceMappingURL=Menu.js.map","import { __decorate } from \"tslib\";\r\nimport * as React from \"react\";\r\nimport { CSSTransition } from \"react-transition-group\";\r\nimport styled from \"../styled-components\";\r\nimport { observable } from \"mobx\";\r\nimport { observer } from \"mobx-react\";\r\nconst CLASS_NAME = \"fade\";\r\nconst FadeRoot = styled(\"div\").withConfig({ displayName: \"FadeRoot\", componentId: \"sc-1ob2z3h\" }) `\n    & .${CLASS_NAME}-enter,\n    & .${CLASS_NAME}-exit {\n        transition: opacity ${props => props.duration}s ease-in-out;\n    }\n\n    & .${CLASS_NAME}-enter {\n        opacity: 0;\n    }\n\n    & .${CLASS_NAME}-enter-active {\n        opacity: 1;\n    }\n\n    & .${CLASS_NAME}-exit {\n        opacity: 1;\n    }\n\n    & .${CLASS_NAME}-exit-active {\n        opacity: 0;\n    }\n`;\r\nlet Fade = class Fade extends React.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.active = false;\r\n    }\r\n    componentDidMount() {\r\n        if (this.props.enabled === true) {\r\n            this.delayTimer = setTimeout(() => this.active = true, this.props.delay * 1000);\r\n        }\r\n    }\r\n    componentDidUpdate(prevProps) {\r\n        if (prevProps.enabled !== this.props.enabled) {\r\n            if (this.delayTimer) {\r\n                clearTimeout(this.delayTimer);\r\n            }\r\n            this.delayTimer = setTimeout(() => {\r\n                this.active = (this.props.enabled === true);\r\n            }, this.props.delay * 1000);\r\n        }\r\n    }\r\n    componentWillUnmount() {\r\n        if (this.delayTimer) {\r\n            clearTimeout(this.delayTimer);\r\n        }\r\n    }\r\n    render() {\r\n        return (React.createElement(FadeRoot, { duration: this.props.duration, innerRef: this.props.innerRef },\r\n            React.createElement(CSSTransition, { in: this.active && this.props.in, classNames: CLASS_NAME, timeout: this.props.duration * 1000, onExited: this.props.onFinished, unmountOnExit: true },\r\n                React.createElement(\"div\", null, this.props.children))));\r\n    }\r\n};\r\nFade.defaultProps = {\r\n    duration: .2,\r\n    delay: 0,\r\n    in: true,\r\n    enabled: true\r\n};\r\n__decorate([\r\n    observable\r\n], Fade.prototype, \"active\", void 0);\r\nFade = __decorate([\r\n    observer\r\n], Fade);\r\nexport { Fade };\r\n//# sourceMappingURL=Fade.js.map","import * as React from \"react\";\r\nimport styled from \"../../styled-components\";\r\nimport { Box } from \"../../layout/content/box/Box\";\r\nimport { HoverState } from \"../../util/react/HoverState\";\r\nconst StyledBox = styled(Box).withConfig({ displayName: \"StyledBox\", componentId: \"sc-5goxd1\" }) `\n    transition: background-color .2s ease-in-out, border-color .2s ease-in-out;\n`;\r\nconst getColorSet = (state) => (theme) => theme.colors.menu.item[state];\r\nconst getState = (disabled, hover, selected) => {\r\n    if (disabled) {\r\n        return \"disabled\";\r\n    }\r\n    else if (selected) {\r\n        return \"selected\";\r\n    }\r\n    else if (hover) {\r\n        return \"hover\";\r\n    }\r\n    else {\r\n        return \"normal\";\r\n    }\r\n};\r\nexport class MenuItem extends React.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.handleClick = () => {\r\n            if (!this.props.disabled && this.props.onClick) {\r\n                this.props.onClick();\r\n            }\r\n        };\r\n    }\r\n    render() {\r\n        let { disabled, Icon, children, selected } = this.props;\r\n        return React.createElement(\"div\", { onClick: this.handleClick },\r\n            React.createElement(HoverState, null, (hover) => {\r\n                let state = getState(disabled, hover, selected);\r\n                let colorSet = getColorSet(state);\r\n                return React.createElement(StyledBox, { Icon: Icon, iconPlacement: \"left\", colors: colorSet, fullWidth: true, metrics: {\r\n                        fontSize: 12,\r\n                        lineHeight: 14,\r\n                        fontWeight: 400,\r\n                        height: 32,\r\n                        iconSize: 24,\r\n                        letterSpacing: .4,\r\n                        textPaddingTop: 7,\r\n                        textPaddingX: 16\r\n                    } }, children);\r\n            }));\r\n    }\r\n}\r\n//# sourceMappingURL=MenuItem.js.map"],"mappings":"AAEA;;;;;;ACOA;AACA;;;AAGA;;;;AAIA;AAeA;;AASA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAKA;AACA;;;;AAjDA;AAwDA;AACA;AACA;AC9FA;;ACEA;;AAEA;AACA;;AAEA;;AAGA;ACNA;AAAA;AAIA;;;AAJA;;;;AAAA;;;;AAAA;;;;AAAA;;;AAuBA;;ACtBA","sourceRoot":""}